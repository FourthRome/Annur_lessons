# Занятие 1 (программирование)

## Завязка сюжета
На занятии рассмотрели [следующую задачу](https://inf-ege.sdamgia.ru/problem?id=27852) из [варианта](https://inf-ege.sdamgia.ru/test?id=11251586) с РешуЕГЭ:

> Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку [185 311; 185 330], числа, имеющие ровно четыре различных натуральных делителя. Для каждого найденного числа запишите эти четыре делителя в четыре соседних столбца на экране с новой строки. Делители в строке должны следовать в порядке возрастания.
> 
> Например, в диапазоне [12; 14] ровно четыре различных натуральных делителя имеет число 14, поэтому для этого диапазона вывод на экране должен содержать следующие значения:
> 
> 1 2 7 14

Последовав совету [Дональда Кнута](https://ru.wikipedia.org/wiki/%D0%9A%D0%BD%D1%83%D1%82,_%D0%94%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%B4_%D0%AD%D1%80%D0%B2%D0%B8%D0%BD) относительно преждевременной оптимизации (в вольной трактовке его [знаменитой фразы](https://en.wikipedia.org/wiki/Program_optimization#When_to_optimize)), мы сначала рассмотрели решение задачи, в котором не делался досрочный выход из внутреннего цикла (далее "Версия 1"). Затем мы написали вторую версию программы (далее "Версия 2"), в которой прерывали выполнение, найдя достаточно делителей.

## Оценка полученных алгоритмов

Очевидно, не все способы решения произвольной задачи одинаково хороши. **Как сравнивать их между собой?**

Обычно (в олимпиадном программировании) стараются оптимизировать две величины: **скорость работы** программы и **количество требуемой памяти**.[^1]

Скорость работы, если выполняется много однотипных тяжёлых операций, составляющих основную часть программы, можно _приблизительно оценить_ через **количество таких операций**. Это позволяет выразить "нагрузку" на компьютер одним числом. [^2]

### Алгоритмическая сложность и О-нотация

Будем считать, что входные данные программы - это **n однотипных** (не обязательно одинаковых) **элементов**. **Сколько операций требуется алгоритму для обработки этих n элементов?**

Если удастся приблизительно выразить это число операций для алгоритма в виде **какой-то функции `f(n)`**, можно будет понять, **как возрастает нагрузка при увеличении n** (получается т.н. **"асимптотическая оценка"**) и насколько хорошо алгоритм масштабируется. Для описания такого "качества" алгоритма часто используется т.н. [О-нотация](https://ru.wikipedia.org/wiki/%C2%ABO%C2%BB_%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%BE%D0%B5_%D0%B8_%C2%ABo%C2%BB_%D0%BC%D0%B0%D0%BB%D0%BE%D0%B5).

_Дисклеймер: введение О-нотации здесь упрощённое, чтобы не грузить математическим аппаратом, с которым ты познакомишься в 11 классе. Этим определением можно пользоваться, но нужно держать в голове, что в каких-то случаях его нужно применять хитрее._

### Как получить асимптотическую оценку сложности
В полученной функции сперва раскрываем все скобки. Затем отбросим все слагаемые, которые, если взять n _очень-очень-очень большим_, окажутся несущественными. Затем нужно убрать числовой множитель перед тем выражением, что останется.

**Если у нас получилось выражение вида `g(n)`, то принято говорить, что алгоритм имеет [алгоритмическую (вычислительную) сложность](https://ru.wikipedia.org/wiki/%D0%92%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C) `О(g(n))`.**

**Примеры:**
- алгоритм, требующий `3n + 5` операций, имеет сложность `O(n)`;
- алгоритм, требующий `500n^2 + 10000000n + 42` операций, имеет сложность `O(n^2)`;
- алгоритм, требующий `42 100 500` операций, имеет сложность `O(1)`.

**Часто встречаемые "сложности"** (в порядке возрастания "затрат"):
- `O(1)` - константная (сложность алгоритма вообще не зависит от количества входных данных, что, впрочем, не значит, что программа обязательно работает "быстро");
- `O(log n)` - логарифмическая сложность (основание логарифма опущено, т.к. может отличаться и т.к. не существенно для грубой оценки);
- `O(n)` - линейная сложность;
- `O(n log n)` - линейно-логарифмическая сложность;
- `O(n^2)` - квадратичная сложность;
- `О(n^3)` - кубическая сложность.
- `O(a^n)` - экспоненциальная сложность (алгоритмы с такой сложностью почти не масштабируются).

**О-нотация может использоваться для оценки не только времени работы программы, но и затрат памяти.**

## Счастливый финал

Воспользовавшись новым инструментом, мы установили, что алгоритм в "Версии 1" имеет квадратичную сложность (по времени работы), а алгоритм в "Версии 2" - (амортизированную) линейную сложность. **Наша оптимизация оказалась полезной! ^__^**

## Главный поинт
При создании программы следует _(крайне желательно до написания кода)_ **оценить, какую сложность имеет выбранный алгоритм**. Если квадратичную или хуже, а входные данные нам неизвестны, как правило, следует поискать алгоритм получше или оптимизировать имеющийся[^3]. При этом **оптимизировать нужно в первую очередь большие вещи, то, что заметно влияет на производительность** - "полировка" программы радует глаз, но не всегда стоит усилий и времени.


[^1]: Мы немного затронули вопросы [иерархической организации памяти](https://ru.wikipedia.org/wiki/%D0%98%D0%B5%D1%80%D0%B0%D1%80%D1%85%D0%B8%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8), в частности, упомянули [регистры](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0) центрального процессора.
[^2]: Позже мы научимся рассматривать сразу несколько параметров, что позволит более полно оценить алгоритм. Обычно [не существует серебряной пули](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B5%D0%B1%D1%80%D1%8F%D0%BD%D0%BE%D0%B9_%D0%BF%D1%83%D0%BB%D0%B8_%D0%BD%D0%B5%D1%82), приходится немного жертвовать одним показателем ради улучшения другого.
[^3]:  Нужно уметь понимать, какой из этих двух путей более перспективный в конкретной ситуации. Это придёт с практикой. :)